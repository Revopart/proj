# 1 Введение {#Introduction-1}

Check — это фреймворк для модульного тестирования в языке программирования C. Он был вдохновлен аналогичными фреймворками, которые существуют для большинства языков программирования; наиболее известный пример — [JUnit](http://www.junit.org/) для Java. Список фреймворков для модульного тестирования различных языков можно найти на [этой странице](http://www.xprogramming.com/software.htm). Модульное тестирование имеет долгую историю в рамках формальных методологий обеспечения качества, но в последнее время оно ассоциируется с легковесной методологией под названием Экстремальное программирование. В рамках этой методологии характерной практикой является чередование написания модульных тестов с написанием кода («немного протестировать, немного написать кода»). Хотя такой пошаговый подход к тестированию и программированию является неотъемлемой частью Экстремального программирования, он также применим и вне этой методологии.

Пошаговый подход тестирования и кодирования предоставляет разработчику три основных преимущества:

1. Поскольку модульные тесты используют интерфейс тестируемого модуля, они позволяют разработчику рано задуматься о том, как должен быть спроектирован интерфейс для использования на ранних этапах процесса кодирования.
2. Они помогают разработчику заранее думать о нестандартных случаях и соответственно программировать.
3. Предоставляя документированный уровень корректности, они позволяют разработчику агрессивно рефакторить код (см. [Refactoring.com](http://www.refactoring.com)).

Третья причина заставляет людей становиться зависимыми от модульного тестирования. Нет ничего более удовлетворительного, чем полностью заменить реализацию, и при каждом шаге этого изменения модульные тесты подтверждают, что все в порядке. Это как разница между исследованием дикой природы с хорошей картой и компасом и без них: без подходящего снаряжения вы, скорее всего, будете двигаться осторожно и придерживаться размеченных троп, а с ним вы можете выбрать самый прямой путь к своей цели.

Для получения последней информации о Check посетите [домашнюю страницу Check](https://libcheck.github.io/check/).

Страница проекта Check находится на [GitHub](https://github.com/libcheck/check).

---

# 2 Модульное тестирование в C {#Unit-Testing-in-C-1}

Подход к фреймворкам модульного тестирования, используемым в Check, произошёл от Smalltalk, который является объектно-ориентированным языком с поздним связыванием и поддержкой рефлексии. Создание фреймворка для языка C требует решения некоторых специальных проблем, с которыми фреймворки для Smalltalk, Java или Python не сталкиваются. В этих языках наихудший результат модульного теста — это его неудачное завершение с выбросом исключения. В C модульный тест так же может "испортить" своё адресное пространство, как и не выполнить свои тестовые требования, и если фреймворк тестирования находится в том же адресном пространстве, это приведет к его завершению.

Для решения этой проблемы Check использует системный вызов `fork()` для создания нового адресного пространства для каждого модульного теста, а затем использует очереди сообщений для отправки информации о процессе тестирования обратно в тестовый фреймворк. Таким образом, ваш модульный тест может совершать всевозможные опасные действия с указателями, вызывать ошибки сегментации, а тестовый фреймворк будет счастливо отмечать ошибки модульных тестов и продолжать работу.

Фреймворк Check также разработан так, чтобы хорошо интегрироваться с общими средами разработки для программирования на C. Автор разработал Check вокруг Autoconf/Automake (отсюда и название Check: команда `make check` используется для тестирования с Autoconf/Automake). Однако использование Autoconf/Automake не является необходимым для использования Check; подойдет любая система сборки. Сообщения о неудачах тестов, которые выводит Check, используют общий шаблон `<filename:linenumber:message>`, который используют `gcc` и его аналоги для сообщения о проблемах в исходном коде. С помощью (X)Emacs вывод Check позволяет быстро перейти к месту неудачного модульного теста; предполагается, что это также работает в VI и IDE.

---

## 2.1 Другие фреймворки для C {#Other-Frameworks-for-C-1}

Авторы знают о следующих дополнительных фреймворках модульного тестирования для языка C:

- **AceUnit**: AceUnit (Advanced C and Embedded Unit) позиционирует себя как комфортный фреймворк для модульного тестирования кода C. Он стремится имитировать JUnit 4.x и включает возможности, подобные рефлексии. AceUnit можно использовать в средах с ограниченными ресурсами, например, в разработке встроенного программного обеспечения. Он отлично работает в средах, где невозможно использовать стандартные заголовочные файлы или вызвать стандартные функции C из библиотек ANSI/ISO. У AceUnit также есть версия для Windows. Он не использует разветвления для перехвата сигналов, хотя авторы выразили интерес к добавлению такой функции. [Домашняя страница AceUnit](http://aceunit.sourceforge.net/).
- **GNU Autounit**: Похож на Check, включая разветвление для запуска модульных тестов в отдельном адресном пространстве. GNU Autounit интенсивно использует GLib, что требует специальных настроек при компоновке, но это может не быть проблемой, особенно если вы уже используете GTK или GLib. [Домашняя страница GNU Autounit](http://autounit.tigris.org/).
- **cUnit**: Также использует GLib, но не выполняет разветвление для защиты адресного пространства модульных тестов. [Архивированная домашняя страница cUnit](http://web.archive.org/web/*/http://people.codefactory.se/~spotty/cunit/).
- **CUnit**: Стандартный C, планируется реализация графического интерфейса для Win32. В настоящее время не использует разветвление или другие способы защиты адресного пространства модульных тестов. Находится в начальной стадии разработки. [Домашняя страница CUnit](http://cunit.sourceforge.net).
- **CuTest**: Простой фреймворк, состоящий всего из одного файла .c и одного файла .h, которые вы добавляете в своё дерево исходников. [Домашняя страница CuTest](http://cutest.sourceforge.net).
- **CppUnit**: Ведущий фреймворк модульного тестирования для C++; его также можно использовать для тестирования кода C. Он стабилен, активно развивается и имеет графический интерфейс. Основные причины не использовать CppUnit для C — это его большой размер и необходимость писать тесты на C++, что требует компилятора C++. Если это не кажется проблемой, стоит рассмотреть его наряду с другими фреймворками модульного тестирования для C++. [Домашняя страница CppUnit](http://cppunit.sourceforge.net/cppunit-wiki).
- **embUnit**: Еще один фреймворк модульного тестирования для встроенных систем, кажется, что он уступил место AceUnit. [Домашняя страница embUnit](https://sourceforge.net/projects/embunit/).
- **MinUnit**: Минимальный набор макросов — вот и всё! Главная цель — показать, насколько легко можно тестировать ваш код. [Домашняя страница MinUnit](http://www.jera.com/techinfo/jtns/jtn002.html).
- **CUnit для Mr. Ando**: Довольно новая реализация CUnit, видимо, все еще находится на ранней стадии разработки. [Домашняя страница CUnit для Mr. Ando](http://park.ruru.ne.jp/ando/work/CUnitForAndo/html/).

Этот список был последний раз обновлен в марте 2008 года. Если вы знаете другие фреймворки модульного тестирования для C, пожалуйста, отправьте электронное письмо с описанием на [check-devel AT lists.sourceforge.net](mailto:check-devel AT lists.sourceforge.net), и мы добавим запись в этот список.

По мнению авторов, использование разветвления или других методов перехвата и сообщения о сигналах необходимо для модульного тестирования (но, вероятно, несложно добавить эту функцию к фреймворкам, которые её не имеют). Попробуйте все: адаптируйте этот учебник для использования всех вышеуказанных фреймворков и используйте тот, который вам больше всего нравится. Вносите свой вклад, распространяйте информацию и сделайте один из них стандартом. Языки, такие как Java и Python, имеют стандартные фреймворки модульного тестирования; желательно, чтобы C тоже имел такой.

---

# Учебник: Основы модульного тестирования {#Tutorial_003a-Basic-Unit-Testing}

Этот учебник будет использовать статью [Test Infected](http://junit.sourceforge.net/doc/testinfected/testing.htm) из документации JUnit в качестве отправной точки. Мы будем создавать библиотеку `libmoney`, предназначенную для представления денег, которая позволяет осуществлять конвертации между различными типами валют. Стиль разработки будет "немного протестируй, немного напиши код", при этом написание модульных тестов будет предшествовать кодированию. Это постоянно дает нам представление о использовании модуля и также гарантирует, что мы постоянно думаем о том, как тестировать наш код.

## Навигация по разделам учебника

- [3.1 Как написать тест](#3.1-как-написать-тест)
- [3.2 Настройка сборки Money с использованием Autotools](#Setting-Up-the-Money-Build-Using-Autotools)
- [3.3 Настройка сборки Money с использованием CMake](#Setting-Up-the-Money-Build-Using-CMake)
- [3.4 Тестируй немного, пиши код немного](#Test-a-Little)
- [3.5 Создание набора тестов](#Creating-a-Suite)
- [3.6 Вывод SRunner](#SRunner-Output)

---

## 3.1 Как написать тест

Написание теста с использованием Check очень простое. В файле, где определены проверки, должен быть включен заголовочный файл `check.h`, как показано ниже:

```c
#include <check.h>
```

Базовый модульный тест выглядит следующим образом:

```c
START_TEST(test_name)
{
  /* код модульного теста */
}
END_TEST
```

Макросы `START_TEST` и `END_TEST` создают базовые структуры, необходимые для проведения тестирования. Пропуск макроса `END_TEST` является ошибкой, так как это может вызвать различные странные ошибки при компиляции теста.

---

## 3.2 Настройка сборки Money с использованием Autotools {#Setting-Up-the-Money-Build-Using-Autotools-1}

Поскольку мы создаем библиотеку для работы с деньгами, мы начнем с создания интерфейса в файле `money.h`, реализации в `money.c` и места для хранения наших модульных тестов в `check_money.c`. Мы хотим интегрировать эти основные файлы в нашу систему сборки и потребуемся дополнительной структуры. Для управления всем этим мы будем использовать Autoconf, Automake и их друзей (коллективно известных как Autotools) в этом примере. Обратите внимание, что можно сделать что-то подобное с обычными Makefiles или любой другой системой сборки. По мнению авторов, использовать Autotools проще, чем чистые Makefiles, и они предоставляют встроенную поддержку для запуска тестов.

Обратите внимание, что это не место для объяснения работы Autotools. Если вам нужна помощь для понимания, что происходит за пределами данного объяснения, лучше всего начать с отличного [учебника по Autotools](http://www.lrde.epita.fr/~adl/autotools.html) Александра Дюре-Люца.

Примеры в этом разделе являются частью дистрибутива Check; вам не нужно тратить время на копирование и вставку или, что хуже, перепечатывание их. Найдите документацию Check в вашей системе и посмотрите в директорию `example`. Стандартная директория для дистрибутивов GNU/Linux должна быть `/usr/share/doc/check/example`. Эта директория содержит окончательную версию, достигнутую в конце учебника. Если вы хотите следовать за ней, создайте резервные копии `money.h`, `money.c` и `check_money.c`, а затем удалите оригиналы.

Структура каталогов устанавливается следующим образом:

```
|-- Makefile.am
|-- README
|-- configure.ac
|-- src
|   |-- Makefile.am
|   |-- main.c
|   |-- money.c
|   `-- money.h
`-- tests
|-- Makefile.am
`-- check_money.c
```

Обратите внимание, что это вывод команды `tree`, отличного инструмента для визуализации директорий. Верхнеуровневый `Makefile.am` прост; он просто сообщает Automake, как обрабатывать подкаталоги:

```makefile
SUBDIRS = src . tests
```

Обратите внимание, что `tests` указан последним, потому что код должен тестировать уже скомпилированную библиотеку. `configure.ac` является стандартным шаблоном Autoconf, как указано в учебнике по Autotools и как предлагается командой `autoscan`.

`src/Makefile.am` собирает `libmoney` как архив Libtool и связывает его с приложением, просто названным `main`. Поведение приложения не важно для этого учебника; важно, что ни одна из функций, которые мы хотим тестировать, не появляется в `main.c`; это, вероятно, означает, что единственной функцией в `main.c` должна быть сама `main()`. Чтобы тестировать всё приложение, модульное тестирование не подходит: следует использовать инструмент системного тестирования, такой как Autotest. Если вы действительно хотите протестировать `main()` с использованием Check, переименуйте её во что-то вроде `_myproject_main()` и напишите для неё оболочку.

Основные инструкции по сборке для наших модульных тестов находятся в `tests/Makefile.am`:

```Makefile
## Process this file with automake to produce Makefile.in

TESTS = check_money
check_PROGRAMS = check_money
check_money_SOURCES = check_money.c $(top_builddir)/src/money.h
check_money_CFLAGS = @CHECK_CFLAGS@
check_money_LDADD = $(top_builddir)/src/libmoney.la @CHECK_LIBS@
```

`TESTS` сообщает Automake, какие тестовые программы запустить при выполнении команды `make check`. Аналогично, префикс `check_` в `check_PROGRAMS` фактически исходит из Automake; это указывает на сборку этих программ только при запуске `make check`. (Вспомните, что цель `check` в Automake является происхождением названия Check.) Тест `check_money` — это программа, которую мы будем собирать из `tests/check_money.c`, связывая её как с `src/libmoney.la`, так и с установленным `libcheck.la` в нашей системе. Соответствующие флаги компилятора и компоновщика для использования Check находятся в `@CHECK_CFLAGS@` и `@CHECK_LIBS@`, значения которых определены макросом `AM_PATH_CHECK`.

Теперь, когда вся инфраструктура устроена, мы можем приступить к разработке. `src/money.h` должен содержать только стандартные заголовки C:

```c
#ifndef MONEY_H
#define MONEY_H

#endif /* MONEY_H */
```

`src/money.c` должен быть пустым, а `tests/check_money.c` должен содержать только пустую функцию `main()`:

```c
int main(void)
{
    return 0;
}
```

Создайте систему сборки GNU для проекта, а затем соберите `main` и `libmoney.la` следующим образом:

```bash
$ autoreconf --install
$ ./configure
$ make
```

Команда `autoreconf` определяет, какие команды необходимы для создания или обновления `configure`. Ранее использовался скрипт `autogen.sh` или `bootstrap`, но сейчас это не нужно.

Теперь соберите и запустите тест `check_money` с помощью `make check`. Если все прошло хорошо, `make` должен сообщить, что наши тесты прошли. Неудивительно, потому что тестов на провал нет. Если возникнут проблемы, обязательно посмотрите [Поддерживаемые системы сборки](check_5.html#Supported-Build-Systems).

Это было протестировано на дистрибутиве Linux Mint GNU/Linux Isadora в ноябре 2012 года с использованием Autoconf 2.65, Automake 1.11.1 и Libtool 2.2.6b. Пожалуйста, сообщайте о любых проблемах на [check-devel AT lists.sourceforge.net](mailto:check-devel AT lists.sourceforge.net).

---

## 3.3 Настройка сборки Money с использованием CMake {#Setting-Up-the-Money-Build-Using-CMake}

Поскольку мы создаем библиотеку для работы с деньгами, мы начнем с создания интерфейса в файле `money.h`, реализации в `money.c`, и места для хранения наших модульных тестов в `check_money.c`. Мы хотим интегрировать эти основные файлы в нашу систему сборки, для чего потребуется некоторая дополнительная структура. Для управления всем этим мы будем использовать CMake в этом примере. Обратите внимание, что можно сделать что-то подобное с обычными Makefiles или любой другой системой сборки. По мнению авторов, использовать CMake проще, чем чистые Makefiles, и он предоставляет встроенную поддержку для запуска тестов.

Обратите внимание, что это не место для объяснения работы CMake. Если вам нужна помощь для понимания, что происходит за пределами данного объяснения, лучше всего начать, вероятно, с [домашней страницы проекта CMake](http://www.cmake.org).

Примеры в этом разделе являются частью дистрибутива Check; вам не нужно тратить время на копирование и вставку или, что хуже, перепечатывание их. Найдите документацию Check в вашей системе и посмотрите в директорию `example`, или посмотрите в исходники Check. Если вы используете систему GNU/Linux, стандартная директория должна быть `/usr/share/doc/check/example`. Эта директория содержит окончательную версию, достигнутую в конце учебника. Если вы хотите следовать за ней, создайте резервные копии `money.h`, `money.c`, и `check_money.c`, а затем удалите оригиналы.

Структура каталогов устанавливается следующим образом:

```
.
|-- Makefile.am
|-- README
|-- CMakeLists.txt
|-- cmake
|   |-- config.h.in
|   |-- FindCheck.cmake
|-- src
|   |-- CMakeLists.txt
|   |-- main.c
|   |-- money.c
|   `-- money.h
`-- tests
    |-- CMakeLists.txt
    `-- check_money.c
```

Верхнеуровневый файл `CMakeLists.txt` содержит проверки конфигурации для доступных библиотек и типов, а также определяет подкаталоги для обработки. Файл `cmake/FindCheck.cmake` содержит инструкции для поиска Check в системе и настройки сборки для его использования. Если в системе не установлен `pkg-config`, `cmake/FindCheck.cmake` может не суметь найти Check. В этом случае директорию установки Check необходимо указать вручную, добавив следующую строку в `tests/CMakeLists.txt` (предполагая, что Check установлен в C:\\Program Files\\check):

```cmake
set(CHECK_INSTALL_DIR "C:/Program Files/check")
```

Обратите внимание, что тесты указаны последними, потому что код должен тестировать уже скомпилированную библиотеку.

`src/CMakeLists.txt` собирает `libmoney` как архив и связывает его с приложением, просто названным `main`. Поведение приложения не важно для этого учебника; важно, что ни одна из функций, которые мы хотим тестировать, не появляется в `main.c`; это, вероятно, означает, что единственной функцией в `main.c` должна быть сама `main()`. Чтобы тестировать всё приложение, модульное тестирование не подходит: следует использовать инструмент системного тестирования, такой как Autotest. Если вы действительно хотите протестировать `main()` с использованием Check, переименуйте её во что-то вроде `_myproject_main()` и напишите для неё оболочку.

Теперь, когда вся инфраструктура устроена, мы можем приступить к разработке. `src/money.h` должен содержать только стандартные заголовки C:

```c
#ifndef MONEY_H
#define MONEY_H

#endif /* MONEY_H */
```

`src/money.c` должен быть пустым, а `tests/check_money.c` должен содержать только пустую функцию `main()`:

```c
int main(void)
{
    return 0;
}
```

Создайте систему сборки CMake для проекта, а затем соберите `main` и `libmoney.la` следующим образом для систем, совместимых с Unix:

```bash
$ cmake .
$ make
```

и для MSVC на Windows:

```bash
$ cmake -G "NMake Makefiles" .
$ nmake
```

Теперь соберите и запустите тест `check_money`, используя либо `make test` на системе, совместимой с Unix, либо `nmake test` на Windows с использованием MSVC. Если все пройдет хорошо, команда должна сообщить, что тесты пройдены. Неудивительно, поскольку тестов на провал нет.

Это было протестировано на Windows 7 с использованием CMake 2.8.12.1 и MSVC 16.00.30319.01 / Visual Studios 10 в феврале 2014 года. Пожалуйста, сообщайте о любых проблемах на [check-devel AT lists.sourceforge.net](mailto:check-devel AT lists.sourceforge.net).

---

## 3.4 Тестируй немного, пиши код немного {#Test-a-Little-Code-a-Little}

Статья ["Test Infected"](http://junit.sourceforge.net/doc/testinfected/testing.htm) начинается с класса `Money`, и мы тоже начнем с него. Конечно, в C мы не можем использовать классы, но это нам и не нужно. Подход "Test Infected" к написанию кода гласит, что мы должны написать модульный тест *до* написания кода, и в этом случае мы будем еще более догматичны и доктринальны, чем авторы "Test Infected" (которые явно не до конца понимают эту тему, несмотря на то, что являются одними из инициаторов подхода Patterns к разработке программного обеспечения и объектно-ориентированному дизайну).

Вот изменения в `check_money.c` для нашего первого модульного теста:

```c
 
#include <check.h>
#include "../src/money.h"

START_TEST(test_money_create)
{
    Money *m;

    m = money_create(5, "USD");
    ck_assert_int_eq(money_amount(m), 5);
    ck_assert_str_eq(money_currency(m), "USD");
    money_free(m);
}
END_TEST

 int main(void)
 {
     return 0;
 }
```

Модульный тест должен просто работать и завершиться. Если он завершится раньше времени или получит сигнал, он завершится с общим сообщением об ошибке. (Заметка: возможно, что вы ожидаете раннего завершения или сигнала, и в Check есть функциональность, которая специально утверждает, что мы должны ожидать сигнал или раннее завершение). Если мы хотим получить информацию о том, что не так, нам нужно использовать некоторые вызовы, которые укажут на ошибку. Два таких вызова - это `ck_assert_int_eq` (используется для определения равенства двух целых чисел) и `ck_assert_str_eq` (используется для определения равенства двух строк с нулевым окончанием). Обе эти функции (на самом деле макросы) сигнализируют об ошибке, если их аргументы не равны.

Альтернативой использованию `ck_assert_int_eq` и `ck_assert_str_eq` является написание тестируемого выражения непосредственно с использованием `ck_assert`. Этот макрос принимает один логический аргумент, который должен быть истинным, чтобы проверка прошла. Второй тест может быть переписан следующим образом:

```c
ck_assert(strcmp (money_currency (m), "USD") == 0);
```

`ck_assert` найдет и сообщит о неудачах, но не будет выводить какие-либо сообщения пользователя в результаты модульного теста. Чтобы выводить определенное пользователем сообщение вместе с найденными ошибками, используйте `ck_assert_msg`. Первый аргумент — это логический аргумент. Оставшиеся аргументы поддерживают `varargs` и принимают строки формата `printf` и аргументы. Это особенно полезно при отладке. Например, второй тест может быть переписан следующим образом:

```c
ck_assert_msg(strcmp (money_currency (m), "USD") == 0,
         "Was expecting a currency of USD, but found %s", money_currency (m));
```

Если логический аргумент слишком сложен для элегантного выражения внутри `ck_assert()`, существуют альтернативные функции `ck_abort()` и `ck_abort_msg()`, которые безусловно приводят к ошибке. Второй тест внутри `test_money_create` выше может быть переписан следующим образом:

```c
if (strcmp (money_currency (m), "USD") != 0) 
  {
    ck_abort_msg ("Currency not set correctly on creation");
  }
```

Для вашего удобства `ck_assert`, который не принимает сообщение, указанное пользователем, подставляет подходящее сообщение за вас. (Это также эквивалентно передаче сообщения `NULL` в `ck_assert_msg`). Таким образом, вы также можете написать тест следующим образом:

```c
ck_assert (money_amount (m) == 5);
```

Это эквивалентно:

```c
ck_assert_msg (money_amount (m) == 5, NULL);
```

что выведет имя файла, номер строки и сообщение `"Assertion 'money_amount (m) == 5' failed"`, если `money_amount (m) != 5`.

Когда мы попытаемся скомпилировать и запустить набор тестов сейчас, используя `make check`, мы получаем множество ошибок компиляции. Может показаться немного странным намеренно писать код, который не будет компилироваться, но обратите внимание на то, что мы делаем: создавая модульный тест, мы также определяем требования к интерфейсу money. Ошибки компиляции, в некотором роде, являются собственными неудачами модульного теста, сообщающими нам, что реализация не соответствует спецификации. Если все, что мы делаем, это редактируем исходные тексты так, чтобы модульный тест компилировался, мы фактически делаем прогресс, руководствуясь модульными тестами, и это то, что мы теперь сделаем.

Мы исправим наш заголовочный файл `money.h` следующим образом:

```c
#ifndef MONEY_H
#define MONEY_H
 
typedef struct Money Money;

Money *money_create(int amount, char *currency);
int money_amount(Money * m);
char *money_currency(Money * m);
void money_free(Money * m);

 #endif /* MONEY_H */
```

Теперь наш код компилируется, и снова проходит все тесты. Однако, как только мы попытаемся *использовать* функции из `libmoney` в `main()` файла `check_money`, мы столкнемся с дополнительными проблемами, так как они еще не были реализованы.

---

## 3.5 Создание набора {#Creating-a-Suite}

Чтобы запустить модульные тесты с помощью Check, мы должны создать несколько тестовых случаев, объединить их в набор и запустить с помощью запускающего устройства для наборов. Это немного обременительно, но в основном делается один раз. Вот изменения для новой версии файла `check_money.c`. Обратите внимание, что мы включаем `stdlib.h`, чтобы получить определения `EXIT_SUCCESS` и `EXIT_FAILURE`.

```c
#include <stdlib.h>
#include <check.h>
#include "../src/money.h"

START_TEST(test_money_create)
{
     Money *m;
 
     m = money_create(5, "USD");
     ck_assert_int_eq(money_amount(m), 5);
     ck_assert_str_eq(money_currency(m), "USD");
     money_free(m);
}
END_TEST
 
Suite * money_suite(void)
{
    Suite *s;
    TCase *tc_core;

    s = suite_create("Money");

    /* Core test case */
    tc_core = tcase_create("Core");

    tcase_add_test(tc_core, test_money_create);
    suite_add_tcase(s, tc_core);

    return s;
}

int main(void)
{
    int number_failed;
    Suite *s;
    SRunner *sr;

    s = money_suite();
    sr = srunner_create(s);

    srunner_run_all(sr, CK_NORMAL);
    number_failed = srunner_ntests_failed(sr);
    srunner_free(sr);
    return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}
```

Большая часть кода в `money_suite()` должна быть понятной без объяснений. Мы создаем набор, создаем тестовый случай, добавляем тестовый случай в набор и добавляем модульный тест, который мы создали выше, в тестовый случай. Почему мы выделяем это в отдельную функцию, а не вставляем прямо в `main()`? Потому что любые новые тесты будут добавлены в `money_suite()`, но в `main()` в рамках этого примера изменений не потребуется, так что `main()` останется относительно чистым и простым.

Модульные тесты внутренне определяются как статические функции. Это означает, что код для добавления модульных тестов к тестовым случаям должен находиться в том же компиляционном блоке, что и сами модульные тесты. Это дает еще одну причину для выделения создания тестового набора в отдельную функцию: позже вы можете захотеть держать один исходный файл на набор; определение уникально названной функции создания набора позволяет вам позже определить заголовочный файл с прототипами для всех функций создания наборов и скрыть детали о том, где и как определены модульные тесты за этими функциями. См. тестовую программу, определенную для самого Check, в качестве примера этой стратегии.

Код в `main()` требует некоторого объяснения. Мы создаем объект исполнителя набора типа `SRunner` из `Suite`, который мы создали в `money_suite()`. Затем мы запускаем suite, используя флаг `CK_NORMAL`, чтобы указать, что мы должны печатать сводку выполнения и перечислить любые возникшие фэйлы. Мы фиксируем количество фэйлов, произошедших во время выполнения, и используем это число, чтобы решить, что вернет `main()`. Цель `check`, созданная Automake, использует возвращаемое значение, чтобы решить, прошли тесты или нет.

Теперь, когда тесты фактически запускаются `check_money`, мы снова сталкиваемся с ошибками компоновщика, когда пробуем `make check`. Попробуйте сами и увидите. Причина в том, что реализация `money.c` для интерфейса `money.h` еще не создана. Давайте выберем самое быстрое возможное решение и реализуем заглушки для каждой из функций в `money.c`. Вот diff:

```c
#include <stdlib.h>
#include "money.h"

Money *money_create(int amount, char *currency)
{
    return NULL;
}

int money_amount(Money * m)
{
    return 0;
}

char *money_currency(Money * m)
{
    return NULL;
}

void money_free(Money * m)
{
    return;
}
```

Обратите внимание, что мы подключаем `<stdlib.h>`, чтобы получить определение `NULL`. Теперь код компилируется и связывается, когда мы запускаем `make check`, но наш модульный тест не проходит. Тем не менее, это уже прогресс, и мы можем сосредоточиться на том, чтобы тест был успешно пройден.

---

## 3.6 Вывод SRunner {#SRunner-Output}

Функции для запуска тестов в `SRunner` определены следующим образом:

```c
void srunner_run_all (SRunner * sr, enum print_output print_mode);

void srunner_run (SRunner *sr, const char *sname, const char *tcname,
                  enum print_output print_mode);
```

Эти функции выполняют две задачи:

1. Они запускают все модульные тесты для выбранных тестовых случаев, определенных для выбранных наборов в `SRunner`, и собирают результаты в `SRunner`. Определение выбранных тестовых случаев и наборов зависит от используемой конкретной функции.

   - `srunner_run_all` запустит все определенные тестовые случаи всех определенных наборов, за исключением случаев, когда определены переменные среды `CK_RUN_CASE` или `CK_RUN_SUITE`. Если эти переменные определены, они должны содержать имя тестового набора или тестового случая, определяя таким образом выбранный набор/тестовый случай.
   - `srunner_run` запустит набор/случай, выбранный параметрами `sname` и `tcname`. Значение `NULL` в каком-либо из этих параметров означает "любой набор/случай".
2. Они выводят результаты в соответствии с указанным `print_mode`.

Для `SRunner`, которые уже были запущены, также определена отдельная функция печати следующим образом:

```c
void srunner_print (SRunner *sr, enum print_output print_mode);
```

Значения перечисления `print_output`, определенные в Check, которые параметр `print_mode` может принимать, следующие:

- `CK_SILENT`: Указывает, что вывод не должен генерироваться. Если вы используете этот флаг, вам нужно либо программно изучить объект `SRunner`, либо печатать отдельно, либо использовать журналирование тестов (см. раздел [Test Logging](check_4.html#Test-Logging)).
- `CK_MINIMAL`: Будет напечатана только сводка исполнения теста (количество запущенных, пройденных, неудачных, ошибок).
- `CK_NORMAL`: Печатает сводку выполнения и сообщение для каждого неудачного теста.
- `CK_VERBOSE`: Печатает сводку и сообщение для каждого теста (пройденного или неудачного).
- `CK_ENV`: Получает режим печати из переменной среды `CK_VERBOSITY`, которая может иметь значения "silent", "minimal", "normal", "verbose". Если переменная не найдена или значение не распознано, режим печати устанавливается в `CK_NORMAL`.
- `CK_SUBUNIT`: Печатает прогресс выполнения через протокол тестового исполнителя [subunit](https://launchpad.net/subunit). Смотрите 'поддержка subunit' в разделе Advanced Features для получения дополнительной информации.

С флагом `CK_NORMAL`, указанным в нашем `main()`, давайте сейчас повторно запустим `make check`. Вывод модульного теста следующий:

```
Running suite(s): Money
0%: Checks: 1, Failures: 1, Errors: 0
check_money.c:9:F:Core:test_money_create:0: Assertion 'money_amount (m)==5' failed: 
money_amount (m)==0, 5==5
FAIL: check_money
=====================================================
1 of 1 test failed
Please report to check-devel AT lists.sourceforge.net
=====================================================
```

Обратите внимание, что вывод из `make check` до Automake 1.13 будет являться выводом программы модульного теста. Начиная с версии 1.13, Automake будет запускать все программы модульных тестов одновременно и сохранять вывод в файлы журналов. Приведенный выше вывод должен быть присутствовать в файле журнала.

Первое число в сводной строке говорит нам, что 0% наших тестов пройдены, а остальная часть строки сообщает, что всего была одна проверка, и из этих проверок, одна неудача и ноль ошибок. Следующая строка точно говорит нам, где произошла эта неудача, и какого рода была неудача (P для прохождения, F для неудачи, E для ошибки).

После этого у нас есть некоторый более высокоуровневый вывод, сгенерированный Automake: программа `check_money` не удалась, и печатается адрес для сообщения о багах, указанный в `configure.ac`.

Давайте реализуем функцию `money_amount`, чтобы она прошла свои тесты. Сначала нам нужно создать структуру Money для хранения суммы, а затем реализовать функцию для возврата правильной суммы:
